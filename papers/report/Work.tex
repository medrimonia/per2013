\section{Work}

\subsection{Generating random graphs}

\subsection{Calculating a sparse spanning subgraph}
% Necessity of implementing FOREST
\paragraph{}
In order to reduce the execution time of the main algorithm, we had to
implement another algorithm described in~\cite{NaIb92}.

% Algo description
\paragraph{}
This algorithm is called \verb!FOREST! and take a graph $G$ as a parameter. The
output is slightly more complicated since it doesn't simply return the
sparse spanning subgraph. Instead, the algorithm returns an array $E$ of size
$m = |E(G)|$. The graph induced by the set of edges $\bigcup \limits_{i=1}^k E_i$
is $k$-connected, if $k$-connectivity of $G$ is greater or equal to $k$.

% Specific data structure
\paragraph{}
The main difficulty about the implementation of this algorithm was the use of a
specific data structure that allowed an access to the maximum, an insertion and
a deletion with a constant amortized cost. Even if such a structure doesn't
exist, it is possible to create one that has all of the required properties for
this algorithm, since the utilisation is very specific and since an element has
always an integer associated value that can grow only from 1 at each step.

% More details ?

%Tests
\paragraph{}
Tests have been created and runned in order to prove that the result of our
implementation of the \verb!FOREST! algorithm was corresponding to the main
objective:
$$\forall k, k \leq K(G),K(V,\bigcup \limits_{i=1}^k E_i) = k$$

\paragraph{}
This test has been validated on simple graphs, but it has also been seened that
our implementation did not produce the expected result if the input was a
multiple graph. We checked this property by following the algorithm on small
multiple graphs and this showed us that the problem wasn't coming from the
implementation, but really from the algorithm.

\subsection{Implementing the algorithm}
% Separation in function + misplaced lines
\paragraph{}
In order to facilitate the comprehension of the algorithm implementation and the
debugging, we chose to separate the different parts of the algorithm. While
we were implementing, we also noticed that some lines where misplaced, breaking
the coherency of the notation.

% Choosing the appropriated data structures
\paragraph{}
In order to have the same complexity as the one prooved in the paper, we sticked
to the same data structures. In order to accept graphs where vertices are not
only integers, we added an HashMap, allowing an access in constant time to the
index of a vertex.

% Tree Manipulation
\paragraph{}
In the library we were using, spanning graphs weren't designed to be modified. We
created our own basic class which was handling Tree with the needed methods like
cutting the tree on a specific vertex.

\subsection{Finding a counter-example}
% Not failing on some entries but on some executions
\paragraph{}
Once the main issues of our implementation of the algorithm were solved, we
had still sometimes issues with the algorithm falling in endless loops. Our
investigations on this specific problem ended with the fact that the problem was
coming from the algorithm and not from the implementation. This was ensured by
verifying the validity of the execution of our algorithm step by step.

\input{report/CounterExample}

% Bad presentation ...
\subsection{Counter-example in general case}
\paragraph{}
In order to ensure that $k=2$ is not a specific case where the algorithm
presented in~\cite{JS94} is not determinist, we will present a proof that an
execution can loop endlessly for any $k$.

\paragraph{}
The proof we will present is a proof by induction. Since we already exhibited
a counter-example for $k=2$, we only need to proove the recurrence.

\paragraph{}
Let $G$ be a $k$-connex graph for which the execution of the algorithm has a
probability of looping endlessly strictly greater than $0$ for the entry
$\{r_1,r_2, \dots, r_k\}$ and $\{n_1,n_2, \dots, n_k\}$. Then a graph $G'$ can
be found such as it is $k+1$-connex and it exists an entry for which the
execution of the algorithm has a probability of looping endlessly strictly
greater than $0$.

\paragraph{Proof:}
If we create $G'$ by adding a new vertex $v$ connected to every vertex of $G$,
i.e. $V(G') = V(G) \cup v$ and
$E(G') = E(G) \cup \bigcup \limits_{u \in V(G)} \{u,v\}$, it is obvious that
$G'$ will be $k+1$-connex, since every minimal vertex cut of $G$ needs to have
 one vertex more in order to be a cut of $G'$.

\paragraph{}
An execution of the algorithm with $G'$, $\{r_1,r_2, \dots, r_k, v\}$,
$\{n_1,n_2, \dots, n_k, 1$ as input will have a probability of looping
endlessly strictly greater than $0$, because the $v$ introduced has no influence
since the associated tree will be full since the beginning and the new edges
won't be useable either.
