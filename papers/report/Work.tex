\section{Work}

%TODO find a better title
\subsection{Tools}
\subsubsection{Generating $k$-connected random graphs}
\paragraph{}
In order to test our implementation of the article algorithm, $k$-connected 
graphs had to be generated. Two methods have been implemented, although the
graphs produced are not uniformly randomised, the generation allow us to test
the algorithm on different types of graphs.

\paragraph{}
The first method is based on the vertex degree. To be $k$-connected, a graph
needs to have vertices of degree $k$. For each vertex, edges will be added
until the vertex has a degree $k$. After that, there is a high probability
that the produced graph is $k$-connected.

\paragraph{}
%TODO explain why : complete component so that the graph is localy dense
Since this first method is not deterministic, we tried another method which was
producing a $k$ connected graph by creating several complete components and
linking them together. The algorithm is described in
Figure~\ref{graphGenerator}.

\begin{algorithm}[!h]
  \KwData{$k$ the connectivity,\\ $N$ the number of components,\\ $n$ the size of components}
  \KwResult{A $k$-connected graph}
  $components = \emptyset$\;
  $edges = \emptyset$\;
  \For{i = 1 to N}{
    $components = components \cup newCompleteComponent(n)$
  }
  \For{i = 1 to N-1}{
    \For{j = 1 to k}{
      $edges = edges \cup (components[i][j], components[i+1][j])$
    }
  }
  $g = newGraph(components, edges)$\;
  \Return{$g$}\;
  \caption{\label{graphGenerator}$k$-connected graph generator}
\end{algorithm}

\paragraph{}
First, the complete components are generated. Then $k$ edges are added between the 
first and the second component then $k$ edges are added between the second and the 
third ones and so on.

%TODO explain clearly
\paragraph{}
The edges between every pair of components are not randomly selected. Let say
that the
vertices of each component are numbered from 1 to the size of the component.
The edges between the vertex 1 of the first and the vertex 1 of the second 
component is selected. The same process is repeated for the second vertices to the
$k$-th vertices and then  for the other components. At the end a $k$-connected 
graph is generated.


 
\subsubsection{Calculating a sparse spanning subgraph}
% Necessity of implementing FOREST
\paragraph{}
In order to reduce the execution time of the main algorithm, we had to
implement another algorithm described in~\cite{NaIb92}.

% Algo description
\paragraph{}
This algorithm is called \verb!FOREST! and takes a graph $G=(V,E)$ as a parameter.
The output is slightly more complicated since it does not simply return the
sparse spanning subgraph. Instead, the algorithm returns an array $A$ of set of
edges. The size of the array returned is $|E(G)|$. The graph induced by the
set of edges $\bigcup \limits_{i=1}^k E_i$
is $k$-connected, if $k$-connectivity of $G$ is greater or equal to $k$.

% Specific data structure
\paragraph{}
The main difficulty about the implementation of this algorithm was the use of a
specific data structure that allowed an access to the maximum, an insertion and
a deletion with a constant amortized cost. Even if such a structure doesn't
exist, it is possible to create one that has all of the required properties for
this algorithm, since the utilisation is very specific and since an element has
always an integer associated value that can grow only from 1 at each step.

% More details ?

%Tests
\paragraph{}
Tests have been created and runned in order to prove that the result of our
implementation of the \verb!FOREST! algorithm was corresponding to the main
objective:
$$\forall k, k \leq K(G),K(V,\bigcup \limits_{i=1}^k E_i) = k$$

\paragraph{}
This test has been validated on simple graphs, but it has also been seened that
our implementation did not produce the expected result if the input was a
multiple graph. We checked this property by following the algorithm on small
multiple graphs and this showed us that the problem wasn't coming from the
implementation, but really from the algorithm.

\subsection{Implementing the algorithm}
% Separation in function + misplaced lines
\paragraph{}
In order to facilitate the comprehension of the algorithm implementation and
the debugging, we choose to present the different parts of the algorithm. While
we were implementing, we also noticed that some lines where misplaced, breaking
the coherency of the algorithm.

% Choosing the appropriated data structures
\paragraph{}
In order to have the same complexity as the one proved in the paper, we sticked
to the same data structures. In order to accept graphs where vertices are not
only integers, we added an HashMap, allowing an access in constant time to the
index of a vertex.

% Tree Manipulation
\paragraph{}
In the library we were using, spanning graphs weren't designed to be modified. We
created our own basic class which was handling trees with the needed methods
like cutting the tree on a specific vertex.

\subsection{Criticism}
\subsubsection{Finding a counter-example}
% Not failing on some entries but on some executions
\paragraph{}
Once the main issues of our implementation of the algorithm were solved, we
had still sometimes issues with the algorithm falling in endless loops. Our
investigations on this specific problem ended with the fact that the problem was
coming from the algorithm and not from the implementation. This was ensured by
verifying the validity of the execution of our algorithm step by step.

\input{report/CounterExample}

\subsubsection{Counter-example in general case}
\paragraph{}
In order to ensure that $k=2$ is not a specific case where the algorithm
presented in~\cite{JS94} is not determinist, we will present a proof that an
execution can loop endlessly for any $k$.

\paragraph{}
The proof we will present is a proof by induction. Since we already exhibited
a counter-example for $k=2$, we only need to proove the recurrence.

\paragraph{}
Let $G$ be a $k$-connex graph for which the execution of the algorithm has a
probability of looping endlessly strictly greater than $0$ for the entry
$\{r_1,r_2, \dots, r_k\}$ and $\{n_1,n_2, \dots, n_k\}$. Then a graph $G'$ can
be found such as it is $k+1$-connex and it exists an entry for which the
execution of the algorithm has a probability of looping endlessly strictly
greater than $0$.

\paragraph{Proof:}
If we create $G'$ by adding a new vertex $v$ connected to every vertex of $G$,
i.e. $V(G') = V(G) \cup v$ and
$E(G') = E(G) \cup \bigcup \limits_{u \in V(G)} \{u,v\}$, it is obvious that
$G'$ will be $k+1$-connex, since every minimal vertex cut of $G$ needs to have
 one vertex more in order to be a cut of $G'$.

\paragraph{}
An execution of the algorithm with $G'$, $\{r_1,r_2, \dots, r_k, v\}$,
$\{n_1,n_2, \dots, n_k, 1$ as input will have a probability of looping
endlessly strictly greater than $0$, because the $v$ introduced has no influence
since the associated tree will be full since the beginning and the new edges
won't be useable either.
% Bad presentation ...
\subsection{Improvements}
\subsubsection{Detecting endless loops}
\paragraph{}
A counter example that shows the algorithm can fall in endless loops have been
exhibited. This raise one question : is it possible to detect when there is an
endless loop? An improvement has been added to the algorithm to exit the
execution when the algorithm enters in an endless loop.

\paragraph{}
To do so, we save the last root index where we have added or swapped a vertex. If
the saved index is equal to the current root index and no vertex have been
added or swap then it means that the algorithm has entered in an endless loop. Then
the execution is stopped.

\subsubsection{Vertex selection condition}
%TODO 
