\subsection{Problem Description}
\paragraph{}
The algorithm proposed in the article~\cite{JS94} claims to be able to find
a $k$-partition in a $k$-connected graph in a polynomial time, more precisely,
it claims that the complexity of the algorithm for a graph $G = (V,E)$ with
$|V| = n$ is $O(k^2 n^2)$.

\paragraph{}
The $k$-partition problem which the article pretends to resolve can be
defined as following. Given a graph $G = (V,E)$, an integer $k$ a set
of vertices $R$ and a set of integers $S$ such as $G$ is $k$-connected,
$R = (r_1, r_2, \dots, r_k )$ is a subset of $V$ containing $k$ vertices and
$S = (s_1, s_2, \dots, s_k )$ contains $k$ integers whose sum is the number of
vertex in $G$. Find a partition $P = (p_1, p_2, \dots, p_k)$ of $V$ in $k$
elements can be found such as for any $i$ from $1$ to $k$, $p_i$ contains
$r_i$ and $|p_i| = s_i$. An illustrated example is presented in
Figure~\ref{fig:inputOutput}.

\newcommand{\formalTitle}[1]{\textbf{\large #1}}

\begin{figure}[H]
  \caption{\label{fig:inputOutput}$k$-partition input}
  \begin{minipage}{.5\textwidth}
    \begin{center}
      \formalTitle{Input}\\
      \begin{tikzpicture}[x=.06\textwidth, y=.06\textwidth,transform shape]
        \input{graphTikZ/inputOutput/input.tex}
      \end{tikzpicture}
    \end{center}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \begin{center}
      \formalTitle{Output}\\
      \begin{tikzpicture}[x=.06\textwidth, y=.06\textwidth,transform shape]
        \input{graphTikZ/inputOutput/output.tex}
      \end{tikzpicture}
    \end{center}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    $$k = 3$$
    $$R = \{a,g,c\}$$
    $$S = \{2,1,4\}$$
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    $$P = \big\{\{a, f\},\{g\},\{b, c, d, e\}\big\}$$
  \end{minipage}
\end{figure}

% Is a formal description really necessary
%\newcommand{\formalTitle}[1]{\textbf{\large #1}}
%\begin{figure}[H]
%  \caption{Formal description of the $k$-partition problem}
%  \begin{minipage}{.5\textwidth}
%    \formalTitle{Input}
%    \small
%    \begin{itemize}
%    \item $G = (V,E)$, a $k$-connected graph
%    \item $k$
%    \item $R$, a list of roots wished for the components
%    \item $S$, a list of the size wished for the components
%    \end{itemize}
%  \end{minipage}
%  \begin{minipage}{.5\textwidth}
%    \formalTitle{Output}
%  \end{minipage}
%\end{figure}

\subsection{Algorithm description}
\subsubsection{Principles}
Main lines of the algorithm

\subsubsection{Data structures}
Data structures

\subsubsection{Acquiring vertices}

\subsubsection{Swapping vertices}

\paragraph{}
Here we are
\\

\paragraph{Algorithm used structures and notations}               
\label{sec:structure}
The algorithm uses its own structures and computes its own values. These are defined in this section.
\begin{description}
\item[Partition trees] represent a tree spanning over a partition of the graph $T_i  a_i$ being 
  the root of the partition. In this part of the report  a tree will refer to a partition tree, unless otherwise specified.
   \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/treePartitionExample.tex}
	\end{center}
	\caption{An example of a partition on the input graph}
      \end{figure}
\item [Tree-Nodes] are arrays of sets of root vertices $\{a_1 \ldots a_k\}$. If $a_j \in$ Tree-node[$v$],the vertex $v$ is or has been a vertex of $T_j$. This table is used to memorize the history of the vertices membership in the partition trees. This will be later used in the algorithm to avoid endless loops and allow vertex exchange.
\begin{table}[H]
\begin{center}
  \begin{tabular}{ | l | c | c | c | c | r | }
    \hline                       
    Vertex & 1 & 2 & 3 & 4 & 5 \\
    \hline
    Set of roots & $\{a_1, a_2\}$ & $\{a_2\}$ & $\{a_3\}$ &$ \emptyset$ & $\emptyset$ \\
    \hline  
    %\caption{An example of a Tree-Node during the algorithm execution}
  \end{tabular}
\end{center}
\end{table}

\item [p] The p-value of a vertex $v$ in a tree $T_i$ the ratio $\dfrac{n_i}{|T_i|}$. The p-value is uniform in all the vertices of a tree, thus we can define the p-calue of a tree as the p-value of any of its vertices. p ensures that the trees are properly filled during the execution of the algorithm. This is due to the fact that a tree will only receive vertices from other trees which p values are lower

\end{description}

\subsubsection{Algorithm progression}

\paragraph{Step 1 : tree expansion}
The first step adds vertices that have never been in a tree before during the algorithm
Whenever there is more vertices than $n_i$ the selection of vertices to add is random. 
After applying this step to every tree we could obtain the following partition.

 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/step1.tex}
	\end{center}
	\caption{step 1 of the 3-connected graph partitioning: tree expansion}
      \end{figure}

\paragraph{Step 2 : potential swappable vertices}
\paragraph{}
The \textcolor{violet}{violet} partition needs an additional vertex that cannot be obtained through the first step. This step will let this tree expand by taking 
a vertex from an other tree.
\paragraph{}
In order to do so, the algorithm compares $p$ values of the \textcolor{violet}{violet} neighbor vertices. As mentionned in ~\ref{sec:structure} $p = \dfrac{n_i}{|V(T_i)|}$ with $T_i$ designating the current partition of the vertex. This step allows us to obtain the set of vertices adjacent to the  \textcolor{violet}{violet} partition that did not belong to this tree and with minimal $p$ value

 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/step2.tex}
	\end{center}
	\caption{step 2 of the 3-connected graph partitioning: potential swappable vertices}
 \end{figure}
\paragraph{Step 3 : vertices selection}
In this step  the list of vertices obtained in the previous step is recovered.
The algorithm then choses a tree among those containing one of the latter vertices. Here the tree $T_1$ is chosen. Then among the vertices to be swapped that in addition are in this tree, the vertex with the highest degree is selected. 

 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/step3.tex}
	\end{center}
	\caption{step 3 of the 3-connected graph partitioning: vertices selection}
      \end{figure}


\paragraph{step 4 vertices swapping}
\paragraph{}
In the last step, before repeating the loop with another tree, the vertices are swapped. To achieve this, The previously selected vertices are cut-off from their previous tree. This means that the vertex and all its children in its previous tree are removed from this partition. Because the algorithm never adds a vertex to a partition where it had already been, these vertices will be swapped to the other trees.

 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/step4.tex}
	\end{center}
	\caption{step 4 of the 3-connected graph partitioning: vertices swapping}
      \end{figure}


\paragraph{Solution}
After running the loop again through the first step for $T_1 and T_5$ we obtain the output partition. The tree $T_1$ obtains \emph{F} as B belonged to $T_1$ and B is then added to $T_5$.
 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/steps56.tex}
	\end{center}
	\caption{progression toward the solution of the 3-connected graph partitioning}
      \end{figure}

