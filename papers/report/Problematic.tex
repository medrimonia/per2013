\subsection{Problem Description}
\paragraph{}
The algorithm proposed in the article~\cite{JS94} claims to be able to find
a $k$-partition in a $k$-connected graph in a polynomial time, more precisely,
it claims that the complexity of the algorithm for a graph $G = (V,E)$ with
$|V| = n$ is $O(k^2 n^2)$.

\paragraph{}
The $k$-partition problem which the article pretends to resolve can be
defined as following. Given a graph $G = (V,E)$, an integer $k$ a set
of vertices $R$ and a set of integers $S$ such as $G$ is $k$-connected,
$R = (r_1, r_2, \dots, r_k )$ is a subset of $V$ containing $k$ vertices and
$S = (s_1, s_2, \dots, s_k )$ contains $k$ integers whose sum is the number of
vertex in $G$. Find a partition $P = (p_1, p_2, \dots, p_k)$ of $V$ in $k$
elements can be found such as for any $i$ from $1$ to $k$, $p_i$ contains
$r_i$ and $|p_i| = s_i$. An illustrated example is presented in
Figure~\ref{fig:inputOutput}.

\newcommand{\formalTitle}[1]{\textbf{\large #1}}

\begin{figure}[H]
  \caption{\label{fig:inputOutput}$k$-partition input}
  \begin{minipage}{.5\textwidth}
    \begin{center}
      \formalTitle{Input}\\
      \begin{tikzpicture}[x=.06\textwidth, y=.06\textwidth,transform shape]
        \input{graphTikZ/inputOutput/input.tex}
      \end{tikzpicture}
    \end{center}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    \begin{center}
      \formalTitle{Output}\\
      \begin{tikzpicture}[x=.06\textwidth, y=.06\textwidth,transform shape]
        \input{graphTikZ/inputOutput/output.tex}
      \end{tikzpicture}
    \end{center}
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    $$k = 3$$
    $$R = \{a,g,c\}$$
    $$S = \{2,1,4\}$$
  \end{minipage}
  \begin{minipage}{.5\textwidth}
    $$P = \big\{\{a, f\},\{g\},\{b, c, d, e\}\big\}$$
  \end{minipage}
\end{figure}

% Is a formal description really necessary
%\newcommand{\formalTitle}[1]{\textbf{\large #1}}
%\begin{figure}[H]
%  \caption{Formal description of the $k$-partition problem}
%  \begin{minipage}{.5\textwidth}
%    \formalTitle{Input}
%    \small
%    \begin{itemize}
%    \item $G = (V,E)$, a $k$-connected graph
%    \item $k$
%    \item $R$, a list of roots wished for the components
%    \item $S$, a list of the size wished for the components
%    \end{itemize}
%  \end{minipage}
%  \begin{minipage}{.5\textwidth}
%    \formalTitle{Output}
%  \end{minipage}
%\end{figure}

\subsection{Algorithm description}
\subsubsection{Principles}
\paragraph{}
The main idea of the algorithm is too expand differents trees from the roots
given as input. The specificities of this expansion is that it is both,
{\em progressive} and {\em balanced}.
\paragraph{}
It is {\em progressive} because the algorithm iterates over the different
components. Each component will try to acquire free vertices (vertices which
do not belong to a component) and if there is no free vertices among it's
neighborhood, it will try to steal a vertex from another component.
\paragraph{}
The algorithm is {\em balanced} because a component can only steal a vertex
from a component which has a lower ratio of the number of wished vertices by
number of vertices currently owned by the component.
\paragraph{}
In order to avoid endless loops engendered by two components stealing the same
vertex one after the other, a memory of the components to which a vertex has
belonged is maintained.
\paragraph{}
A proof of the complexity of this algorithm is given in the
article~\cite{JS94}, this proof can be summarized by the following properties.
\begin{enumerate}
\item The number of iterations of the expansion is in $O(kn)$.
\item Every step of an iteration is in $O(m)$
\item An algorithm exists which has a complexity of $O(m)$ and allows to
  reduce the number of edges in a $k$-connected graph to a number of edge in
  $O(kn)$.
\end{enumerate}
\paragraph{}
From those three properties, we can affirm that the complexity of the
algorithm is in $O(k^2n^2)$. But, even if the second possibility can be
verified and if the validity of the third doesn't influence the fact that this
algorithm is polynomial, the proof of the first property seems to be wrong
since a counter-example has been exhibited where the algorithm loops endlessly
at section~\ref{counter-example}.

\subsubsection{Used data}
Data structures

\subsubsection{Acquiring vertices}

\subsubsection{Stealing vertices}

\paragraph{}
Here we are
\\

\paragraph{Algorithm used structures and notations}               
\label{sec:structure}
The algorithm uses its own structures and computes its own values. These are defined in this section.
\begin{description}
\item[Partition trees] represent a tree spanning over a partition of the graph $T_i  a_i$ being 
  the root of the partition. In this part of the report  a tree will refer to a partition tree, unless otherwise specified.
   \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/treePartitionExample.tex}
	\end{center}
	\caption{An example of a partition on the input graph}
      \end{figure}
\item [Tree-Nodes] are arrays of sets of root vertices $\{a_1 \ldots a_k\}$. If $a_j \in$ Tree-node[$v$],the vertex $v$ is or has been a vertex of $T_j$. This table is used to memorize the history of the vertices membership in the partition trees. This will be later used in the algorithm to avoid endless loops and allow vertex exchange.
\begin{table}[H]
\begin{center}
  \begin{tabular}{ | l | c | c | c | c | r | }
    \hline                       
    Vertex & 1 & 2 & 3 & 4 & 5 \\
    \hline
    Set of roots & $\{a_1, a_2\}$ & $\{a_2\}$ & $\{a_3\}$ &$ \emptyset$ & $\emptyset$ \\
    \hline  
    %\caption{An example of a Tree-Node during the algorithm execution}
  \end{tabular}
\end{center}
\end{table}

\item [p] The p-value of a vertex $v$ in a tree $T_i$ the ratio $\dfrac{n_i}{|T_i|}$. The p-value is uniform in all the vertices of a tree, thus we can define the p-calue of a tree as the p-value of any of its vertices. p ensures that the trees are properly filled during the execution of the algorithm. This is due to the fact that a tree will only receive vertices from other trees which p values are lower

\end{description}

\subsubsection{Algorithm progression}

\paragraph{Step 1 : tree expansion}
The first step adds vertices that have never been in a tree before during the algorithm
Whenever there is more vertices than $n_i$ the selection of vertices to add is random. 
After applying this step to every tree we could obtain the following partition.

 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/step1.tex}
	\end{center}
	\caption{step 1 of the 3-connected graph partitioning: tree expansion}
      \end{figure}

\paragraph{Step 2 : potential swappable vertices}
\paragraph{}
The \textcolor{violet}{violet} partition needs an additional vertex that cannot be obtained through the first step. This step will let this tree expand by taking 
a vertex from an other tree.
\paragraph{}
In order to do so, the algorithm compares $p$ values of the \textcolor{violet}{violet} neighbor vertices. As mentionned in ~\ref{sec:structure} $p = \dfrac{n_i}{|V(T_i)|}$ with $T_i$ designating the current partition of the vertex. This step allows us to obtain the set of vertices adjacent to the  \textcolor{violet}{violet} partition that did not belong to this tree and with minimal $p$ value

 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/step2.tex}
	\end{center}
	\caption{step 2 of the 3-connected graph partitioning: potential swappable vertices}
 \end{figure}
\paragraph{Step 3 : vertices selection}
In this step  the list of vertices obtained in the previous step is recovered.
The algorithm then choses a tree among those containing one of the latter vertices. Here the tree $T_1$ is chosen. Then among the vertices to be swapped that in addition are in this tree, the vertex with the highest degree is selected. 

 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/step3.tex}
	\end{center}
	\caption{step 3 of the 3-connected graph partitioning: vertices selection}
      \end{figure}


\paragraph{step 4 vertices swapping}
\paragraph{}
In the last step, before repeating the loop with another tree, the vertices are swapped. To achieve this, The previously selected vertices are cut-off from their previous tree. This means that the vertex and all its children in its previous tree are removed from this partition. Because the algorithm never adds a vertex to a partition where it had already been, these vertices will be swapped to the other trees.

 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/step4.tex}
	\end{center}
	\caption{step 4 of the 3-connected graph partitioning: vertices swapping}
      \end{figure}


\paragraph{Solution}
After running the loop again through the first step for $T_1 and T_5$ we obtain the output partition. The tree $T_1$ obtains \emph{F} as B belonged to $T_1$ and B is then added to $T_5$.
 \begin{figure}[H]
	\begin{center}
	  \input{graphTikZ/AlgoSteps/steps56.tex}
	\end{center}
	\caption{progression toward the solution of the 3-connected graph partitioning}
      \end{figure}

